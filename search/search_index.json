{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to MkDocs","text":"<p>For full documentation visit mkdocs.org.</p>"},{"location":"#commands","title":"Commands","text":"<ul> <li><code>mkdocs new [dir-name]</code> - Create a new project.</li> <li><code>mkdocs serve</code> - Start the live-reloading docs server.</li> <li><code>mkdocs build</code> - Build the documentation site.</li> <li><code>mkdocs -h</code> - Print help message and exit.</li> </ul>"},{"location":"#project-layout","title":"Project layout","text":"<pre><code>mkdocs.yml    # The configuration file.\ndocs/\n    index.md  # The documentation homepage.\n    ...       # Other markdown pages, images and other files.\n</code></pre>"},{"location":"blog/","title":"Blog","text":""},{"location":"blog/2025/06/15/malloclab/","title":"malloclab","text":"<p>\u5185\u5b58\u7ba1\u7406\u5b9e\u9a8c\uff0c\u4e3b\u8981\u76ee\u7684\u662f\u5b9e\u73b0\u4e00\u4e2a\u8fd0\u884c\u65f6\u5806\u5185\u5b58\u5206\u914d\u7cfb\u7edf\uff0c\u4e3b\u8981\u987a\u5e8f\u662f</p> <ol> <li>\u9690\u5f0f\u94fe\u8868\u5b9e\u73b0</li> <li>\u7a7a\u95f2\u663e\u5f0f\u94fe\u8868\u5b9e\u73b0</li> <li>\u5206\u79bb\u5f0f\u7a7a\u95f2\u94fe\u8868\u5b9e\u73b0</li> <li>\u9762\u5411\u7279\u6b8a\u7c7b\u578b\u6570\u636e</li> </ol> <pre><code>/*\n * mm-naive.c - The fastest, least memory-efficient malloc package.\n * \n * In this naive approach, a block is allocated by simply incrementing\n * the brk pointer.  A block is pure payload. There are no headers or\n * footers.  Blocks are never coalesced or reused. Realloc is\n * implemented directly using mm_malloc and mm_free.\n *\n * NOTE TO STUDENTS: Replace this header comment with your own header\n * comment that gives a high level description of your solution.\n */\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;assert.h&gt;\n#include &lt;unistd.h&gt;\n#include &lt;string.h&gt;\n#include &lt;math.h&gt;\n#include \"mm.h\"\n#include \"memlib.h\"\n\n/*********************************************************\n * NOTE TO STUDENTS: Before you do anything else, please\n * provide your team information in the following struct.\n ********************************************************/\nteam_t team = {\n    /* Team name */\n    \"ateam\",\n    /* First member's full name */\n    \"Harry Bovik\",\n    /* First member's email address */\n    \"bovik@cs.cmu.edu\",\n    /* Second member's full name (leave blank if none) */\n    \"\",\n    /* Second member's email address (leave blank if none) */\n    \"\"\n};\n\n/* single word (4) or double word (8) alignment */\n#define ALIGNMENT 8\n\n/* rounds up to the nearest multiple of ALIGNMENT */\n#define ALIGN(size) (((size) + (ALIGNMENT-1)) &amp; ~0x7)\n\n\n#define SIZE_T_SIZE (ALIGN(sizeof(size_t)))\n\n//Header\u7684\u5927\u5c0f\n#define WORD_SIZE (sizeof(unsigned int))\n\n//\u7528\u6765\u5728Header\u4e0a\u5199\u6570\u636e\u6216\u8005\u8bfb\u53d6\u503c\n#define READ(PTR) (*(unsigned int *)(PTR))\n#define WRITE(PTR, VALUE) ((*(unsigned int *)(PTR)) = (VALUE))\n\n//\u5c06\u5757\u5927\u5c0f\u548c\u662f\u5426\u88ab\u5360\u7528\u7684\u4fe1\u606f\u5408\u5e76\uff0c\u4fbf\u4e8e\u5199\u5165Header\n#define PACK(SIZE, IS_ALLOC) ((SIZE) | (IS_ALLOC))\n\n//\u4f20\u5165\u6307\u5411Header\u7684\u6307\u9488p\uff0c\u8fd4\u56de\u5176\u540e\u7684\u8d1f\u8f7d\u5757\u7684\u957f\u5ea6\n#define GET_SIZE(PTR) (unsigned int)((READ(PTR) &gt;&gt; 3) &lt;&lt; 3)\n//\u4f20\u5165\u6307\u5411Header\u7684\u6307\u9488p\uff0c\u8fd4\u56de\u5176\u540e\u7684\u8d1f\u8f7d\u5757\u662f\u5426\u88ab\u5360\u7528\n#define IS_ALLOC(PTR) (READ(PTR) &amp; (unsigned int)1)\n\n//\u4f20\u5165\u6307\u5411\u8d1f\u8f7d\u9996\u4e2a\u5b57\u8282\u7684\u6307\u9488\uff0c\u8fd4\u56de\u6307\u5411\u8fd9\u4e2a\u5757\u7684\u5934/\u5c3e\u7684\u6307\u9488\n#define HEAD_PTR(PTR) ((void *)(PTR) - WORD_SIZE)\n#define TAIL_PTR(PTR) ((void *)(PTR) + GET_SIZE(HEAD_PTR(PTR)) - WORD_SIZE * 2)\n\n//\u4f20\u5165\u6307\u5411\u8d1f\u8f7d\u9996\u4e2a\u5b57\u8282\u7684\u6307\u9488\uff0c\u8fd4\u56de\u6307\u76f8\u90bb\u7684\u4e0b\u4e00\u4e2a\u5757/\u4e0a\u4e00\u4e2a\u5757\u7684\u6307\u9488\n#define NEXT_BLOCK(PTR) ((void *)(PTR) + GET_SIZE(HEAD_PTR(PTR)))\n#define PREV_BLOCK(PTR) ((void *)(PTR) - GET_SIZE((void *)(PTR) - WORD_SIZE * 2))\n\n#define MAX(X, Y) ((X) &gt; (Y) ? (X) : (Y))\n#define PAGE_SIZE (1 &lt;&lt; 12)\n\n//\u7a7a\u95f2\u94fe\u8868\u8865\u5145\u5b8f\u5b9a\u4e49\n#define GETADDR(PTR) (*(void **)PTR)//\u627e\u5230\u5f53\u524d\u6307\u9488\u6240\u6307\u5411\u7684\u6307\u9488\n#define PUTADDR(PTR, ADDR) (*(void **)PTR = (void *)ADDR)//\u5411\u5f53\u524d\u6307\u9488\u8f93\u5165\u6307\u9488\n\n#define PREV_BLOCK_UP(PTR) ((void *)PTR) //\u6307\u5411\u4e0a\u4e00\u4e2a\u7a7a\u95f2\u5757\u7684\u6307\u9488\n#define NEXT_BLOCK_UP(PTR) ((void *)PTR + 2 * WORD_SIZE) //\u6307\u5411\u4e0b\u4e00\u4e2a\u7a7a\u95f2\u5757\u7684\u6307\u9488\n\n/*\u5206\u79bb\u5f0f\u663e\u5f0f\u94fe\u8868\uff0c\u76ee\u524d\u786e\u5b9a\u9700\u8981\u7ef4\u62a4\u4e00\u4e2a\u7a7a\u95f2\u94fe\u8868\u5934\u8282\u70b9\u7684\u7ec4\u5728\u5e8f\u8a00\u5757\u4e2d\uff0c\u5e8f\u8a00\u5757\u4e2d\u5e94\u8be5\u9700\u898132*\uff08void*\uff09\u4ee5\u4e0a\u7684\u8d1f\u8f7d\u7a7a\u95f4\uff0c\u5c1a\u672a\u786e\u5b9a\n\u4f7f\u7528\u53d6\u5bf9\u6570\u7684\u65b9\u6cd5\u6765\u786e\u5b9a\u662f\u54ea\u4e00\u4e2a\u94fe\u8868\u5934\uff0c\u8fd9\u6837\u540c\u65f6\u4e5f\u53ef\u4ee5\u907f\u514d\u7528\u6570\u7ec4\uff0c\u800c\u662f\u76f4\u63a5\u4f7f\u7528\u5730\u5740\u5bfb\u627e\u5bf9\u5e94\u5934\u8282\u70b9\n\u8fd9\u6837\u7684\u8bdd\uff0c\u90a3\u4e48\u7a7a\u95f2\u94fe\u8868\u5934\u8282\u70b9heap_free_first\u5c06\u4e0d\u518d\u9700\u8981\uff0c\u7b2c\u4e00\u4e2a\u8d1f\u8f7d\u4f4d\u7f6e\u53ef\u4ee5\u653e\uff0816\uff0c32\uff09\uff0c\u7b2c\u4e8c\u4e2a\u8d1f\u8f7d\u653e\uff0832\uff0c64\uff09\u4ee5\u6b64\u7c7b\u63a8\uff0c\n\u53c8\u8d1f\u8f7d\u957f\u5ea6\u4e0d\u4f1a\u8d85\u8fc72\u768432\u6b21\u65b9\uff0c\u90a3\u4e48\u6700\u5927\u7684\u533a\u95f4\u5e94\u8be5\u662f(2^31,2^32),\u90a3\u4e48\u9700\u8981\u5b58\u7684\u6307\u9488\u5c31\u670932-4+1=29\u4e2a\u6307\u9488\uff0c\n\u9700\u8981\u5e8f\u8a00\u5757\u662f30*\uff08void*\uff09\u7684\u957f\u5ea6\uff08\u52a0\u4e0a\u4e24\u4e2a\u5934\u5c3e\uff09\uff0c\u7136\u540e\u8fdb\u884c\u884c\u67e5\u627e\u548c\u63d2\u5165\u5220\u9664\u7684\u65f6\u5019\u4f7f\u7528log(size)\u5411\u4e0b\u53d6\u6574\u6765\u627e\u5230\u5bf9\u5e94\u6240\u9700\u5757\uff0c\u66f4\u7b80\u5355\u7684\uff0c\u6211\u4eec\u53ef\u4ee5\u76f4\u63a5\u7ed9\n\u5e8f\u8a00\u5757\u7533\u8bf732*\uff08void*\uff09\u7684\u8d1f\u8f7d\uff0c33*\uff08void*\uff09\u7684\u957f\u5ea6\uff0c\u4ece\u8d1f\u8f7d\u7684\u7b2c\u56db\u4e2a\u6307\u9488\u5757\u5f00\u59cb\u8fdb\u884c\u7b2c\u4e00\u7c7b\u5927\u5c0f\u7a7a\u95f2\u8868\u7684\u5206\u914d\uff0c\u8fd9\u6837\u627e\u8d77\u6765\u5c31\u66f4\u52a0\u7b80\u5355\uff0c\u90a3\u4e48heap_free_first\u53c8\u53ef\u4ee5\u7528\u4e86\uff0c\u5148\n\u8865\u5145\u5b8f\u5b9a\u4e49\u67e5\u627e\u5934\u8282\u70b9\u4f4d\u7f6e\uff0c\u518d\u7ed9\u4e00\u4e2aheap_youneed\n\u9700\u8981\u6ce8\u610f\u7684\u4e00\u70b9\u662f\uff0c\u5982\u679c\u5728\u5f53\u524d\u8303\u56f4\u6ca1\u627e\u5230\u5408\u9002\u7684\u9002\u914d\uff0c\u5e94\u8be5\u5411\u4e0a\u5bfb\u627e\u9002\u914d\uff0c\u627e\u4e0d\u5230\u624d\u5f00\u7a7a\u95f4\uff0c\u8fd9\u91cc\u662f\u4e2abug\u70b9*/\n#define MATCH(PTR) ((int)(log2(GET_SIZE(HEAD_PTR(PTR))))) * sizeof(void*)//\u4f7f\u7528int\u6765\u9020\u6210\u5411\u4e0b\u53d6\u6574\nvoid * heap_youneed;\n\n// static void * heapfirst;\nstatic void * heap_free_first;//\u7a7a\u95f2\u94fe\u8868\u5934\uff0c\u5728\u5206\u79bb\u5f0f\u663e\u5f0f\u94fe\u8868\u53ef\u4ee5\u6307\u5411\u7b2c\u4e00\u4e2a\u8d1f\u8f7d\uff0c\u7136\u540e\u8981\u53d6\u5934\u8282\u70b9\u65f6\u52a0\u4e0a\u5bf9\u5e94\u7684MATCH\uff08PTR\uff09\u5373\u53ef\nstatic void * heap_free_last;\nvoid remove_free(void * ptr);\n// void place_free(void * ptr);\nvoid insert_free(void * ptr);\n\nvoid *Merge(void *Ptr) {\n    int if_front = IS_ALLOC(HEAD_PTR(PREV_BLOCK(Ptr)));//\u68c0\u67e5\u524d\u9762\u7684\u5757\u662f\u5426\u7a7a\u95f2\n    void * PREV = PREV_BLOCK(Ptr);\n    int if_back = IS_ALLOC(HEAD_PTR(NEXT_BLOCK(Ptr)));//\u68c0\u67e5\u540e\u9762\u7684\u5757\u662f\u5426\u7a7a\u95f2\n    void * NEXT = NEXT_BLOCK(Ptr);\n    if(!IS_ALLOC(HEAD_PTR(Ptr))) remove_free(Ptr);\n    size_t size = GET_SIZE(HEAD_PTR(Ptr));//\u5f97\u5230\u5f53\u4e0b\u5757\u7684\u5934\u4e2d\u7684\u5757\u957f\u5ea6\n\n    if(if_front &amp;&amp; if_back);//\u524d\u540e\u90fd\u88ab\u5206\u914d\uff0c\u4e0d\u7528\u5408\u5e76\u7a7a\u95f2\u5757\n    else if(if_front &amp;&amp; !if_back){\n        remove_free(NEXT);\n        size += GET_SIZE(HEAD_PTR(NEXT_BLOCK(Ptr)));//\u524d\u9762\u88ab\u5206\u914d\uff0c\u5408\u5e76\u540e\u65b9\uff0c\u4e0d\u7528\u7ba1\u5934\u6307\u9488\n    }\n    else if(!if_front &amp;&amp; if_back){\n        remove_free(PREV);\n        size += GET_SIZE(HEAD_PTR(PREV_BLOCK(Ptr)));//\u540e\u9762\u88ab\u5206\u914d\n        Ptr = PREV_BLOCK(Ptr);//\u53d8\u4e3a\u524d\u9762\u7684\u5757\n    }\n    else{\n        remove_free(PREV);\n        remove_free(NEXT);\n        size += GET_SIZE(HEAD_PTR(NEXT_BLOCK(Ptr))) + GET_SIZE(TAIL_PTR(PREV_BLOCK(Ptr)));\n        Ptr = PREV_BLOCK(Ptr);\n    }\n\n    WRITE(HEAD_PTR(Ptr), PACK(size, 0));\n    WRITE(TAIL_PTR(Ptr), PACK(size, 0));\n    insert_free(Ptr);\n    return Ptr;\n}\n\nvoid Place(void *Ptr, unsigned int Size) {\n    size_t total = GET_SIZE(HEAD_PTR(Ptr));\n    size_t remain = total - Size;\n\n    //\u9762\u5411\u6570\u636e1\uff0c\u6b64\u5904\u5982\u679csize\u662f64\u4f4d\uff0c\u5212\u5206\u516b\u6b2164\u4f4d(\u52a0\u4e0a\u5934\u5c31\u662f72)\uff0c\u516b\u6b21448\u4f4d\uff08\u52a0\u4e0a\u5934\u5c31\u662f456\uff09\n    if(Size == 72 &amp;&amp; total == 4224){\n\n        if(!IS_ALLOC(HEAD_PTR(Ptr)))remove_free(Ptr);\n        WRITE(HEAD_PTR(Ptr), PACK(72, 1));\n        WRITE(TAIL_PTR(Ptr), PACK(72, 1));\n\n        Ptr = NEXT_BLOCK(Ptr);\n\n        WRITE(HEAD_PTR(Ptr), PACK(remain, 0));\n        WRITE(TAIL_PTR(Ptr), PACK(remain, 0));\n        insert_free(Ptr);\n\n        for(int i = 1; i &lt; 8; i++){\n            remain -= 72;\n\n            if(!IS_ALLOC(HEAD_PTR(Ptr)))remove_free(Ptr);\n            WRITE(HEAD_PTR(Ptr), PACK(72, 0));\n            WRITE(TAIL_PTR(Ptr), PACK(72, 0));\n\n            insert_free(Ptr);\n\n            Ptr = NEXT_BLOCK(Ptr);\n\n            WRITE(HEAD_PTR(Ptr), PACK(remain, 0));\n            WRITE(TAIL_PTR(Ptr), PACK(remain, 0));\n            insert_free(Ptr);\n        }\n        for(int i = 0; i &lt; 8; i++){\n            remain -= 456;\n\n            if(!IS_ALLOC(HEAD_PTR(Ptr)))remove_free(Ptr);\n            WRITE(HEAD_PTR(Ptr), PACK(456, 0));\n            WRITE(TAIL_PTR(Ptr), PACK(456, 0));\n\n            insert_free(Ptr);\n\n            Ptr = NEXT_BLOCK(Ptr);\n\n            if(remain &gt; 0){\n            WRITE(HEAD_PTR(Ptr), PACK(remain, 0));\n            WRITE(TAIL_PTR(Ptr), PACK(remain, 0));\n            insert_free(Ptr);\n            }\n        }\n\n    }\n    else if(Size == 24 &amp;&amp; total == 5120){\n\n        if(!IS_ALLOC(HEAD_PTR(Ptr)))remove_free(Ptr);\n        WRITE(HEAD_PTR(Ptr), PACK(24, 1));\n        WRITE(TAIL_PTR(Ptr), PACK(24, 1));\n\n        Ptr = NEXT_BLOCK(Ptr);\n\n        WRITE(HEAD_PTR(Ptr), PACK(remain, 0));\n        WRITE(TAIL_PTR(Ptr), PACK(remain, 0));\n        insert_free(Ptr);\n\n        for(int i = 1; i &lt; 32; i++){\n            remain -= 24;\n\n            if(!IS_ALLOC(HEAD_PTR(Ptr)))remove_free(Ptr);\n            WRITE(HEAD_PTR(Ptr), PACK(24, 0));\n            WRITE(TAIL_PTR(Ptr), PACK(24, 0));\n\n            insert_free(Ptr);\n\n            Ptr = NEXT_BLOCK(Ptr);\n\n            WRITE(HEAD_PTR(Ptr), PACK(remain, 0));\n            WRITE(TAIL_PTR(Ptr), PACK(remain, 0));\n            insert_free(Ptr);\n        }\n        for(int i = 0; i &lt; 32; i++){\n            remain -= 136;\n\n            if(!IS_ALLOC(HEAD_PTR(Ptr)))remove_free(Ptr);\n            WRITE(HEAD_PTR(Ptr), PACK(136, 0));\n            WRITE(TAIL_PTR(Ptr), PACK(136, 0));\n\n            insert_free(Ptr);\n\n            Ptr = NEXT_BLOCK(Ptr);\n\n            if(remain &gt; 0){\n            WRITE(HEAD_PTR(Ptr), PACK(remain, 0));\n            WRITE(TAIL_PTR(Ptr), PACK(remain, 0));\n            insert_free(Ptr);\n            }\n        }\n    }\n    else{\n    if(remain &gt;= 24){\n        if(!IS_ALLOC(HEAD_PTR(Ptr)))remove_free(Ptr);\n        WRITE(HEAD_PTR(Ptr), PACK(Size, 1));\n        WRITE(TAIL_PTR(Ptr), PACK(Size, 1));\n\n        Ptr = NEXT_BLOCK(Ptr);\n\n        WRITE(HEAD_PTR(Ptr), PACK(remain, 0));\n        WRITE(TAIL_PTR(Ptr), PACK(remain, 0));\n        insert_free(Ptr);\n    }\n    else{\n        if(!IS_ALLOC(HEAD_PTR(Ptr)))remove_free(Ptr);\n        WRITE(HEAD_PTR(Ptr), PACK(total, 1));\n        WRITE(TAIL_PTR(Ptr), PACK(total, 1));\n    }\n}\n\n}\n\nvoid *FirstFit(size_t Size) {\n    // void * re = heap_free_first;\n    // for(re = heap_free_first; re != NULL; re = GETADDR(NEXT_BLOCK_UP(re))){\n    //     if(!IS_ALLOC(HEAD_PTR(re)) &amp;&amp; GET_SIZE(HEAD_PTR(re)) &gt;= Size) return re;\n    // }\n    // return NULL;\n    heap_youneed = heap_free_first + ((int)(log2(Size))) * sizeof(void*);\n    void *curr = GETADDR(heap_youneed);\n\n    while(heap_youneed != heap_free_last){\n    while (curr) {\n        if (GET_SIZE(HEAD_PTR(curr)) &gt;= Size) {\n            return curr;\n        }\n        curr = GETADDR(NEXT_BLOCK_UP(curr));\n    }\n    heap_youneed += sizeof(void*);\n    curr = GETADDR(heap_youneed);\n}\n    return NULL;\n}\n\nvoid remove_free(void * ptr){\n    heap_youneed = heap_free_first + MATCH(ptr);\n    void * PREV = GETADDR(PREV_BLOCK_UP(ptr));\n    void * NEXT = GETADDR(NEXT_BLOCK_UP(ptr));\n    if(PREV == heap_youneed || heap_youneed == PREV) PUTADDR(heap_youneed, NEXT);\n    else PUTADDR(NEXT_BLOCK_UP(PREV), NEXT);\n    if(NEXT != NULL)PUTADDR(PREV_BLOCK_UP(NEXT), PREV);\n\n    PUTADDR(PREV_BLOCK_UP(ptr), NULL);\n    PUTADDR(NEXT_BLOCK_UP(ptr), NULL);\n}\n\nvoid insert_free(void * ptr){\n    heap_youneed = heap_free_first + MATCH(ptr);\n//     if (GET_SIZE(HEAD_PTR(ptr)) &lt; 24) {\n//     // \u4e0d\u5e94\u52a0\u5165\u7a7a\u95f2\u94fe\u8868\n//     return;\n// }\n    void * NEXT = GETADDR(heap_youneed);\n    PUTADDR(PREV_BLOCK_UP(ptr), heap_youneed);\n    PUTADDR(NEXT_BLOCK_UP(ptr), NEXT);\n    PUTADDR(heap_youneed, ptr);\n    if(NEXT != NULL)    PUTADDR(PREV_BLOCK_UP(NEXT), ptr);\n}\n\n// void place_free(void * ptr){\n//     void * PREV = GETADDR(PREV_BLOCK_UP(ptr));\n//     void * NEXT = GETADDR(NEXT_BLOCK_UP(ptr));\n//     void * next_ptr = NEXT_BLOCK(ptr);\n\n//     PUTADDR(PREV_BLOCK_UP(next_ptr), PREV);\n//     PUTADDR(NEXT_BLOCK_UP(next_ptr), NEXT);\n\n//     if(PREV == heap_free_first){\n//         PUTADDR(heap_free_first, next_ptr);\n//     }\n//     else{\n//         PUTADDR(NEXT_BLOCK_UP(PREV), next_ptr);\n//     }\n\n//     if(NEXT != NULL){\n//         PUTADDR(PREV_BLOCK_UP(NEXT), next_ptr);\n//     }\n// }\n\n/* \n * mm_init - initialize the malloc package.\n */\nint mm_init(void)\n{\n    heap_free_first = mem_sbrk(34 * sizeof(void*));//\u9700\u89814\u4e2a\u5934\u90e8\u5206\uff0c\u4e00\u4e2a\u5e8f\u8a00\u5bf9\u9f50\u5757\uff0c\u4e00\u4e2a\u5e8f\u8a00\u5934\uff0c\u4e00\u4e2a\u5e8f\u8a00\u5c3e\u5df4\uff0c\u8fd8\u6709\u4e00\u4e2a\u7ed3\u5c3e\u5757\uff1b\u8865\u5145\u4e00\u4e2a\u7a7a\u95f2\u5934\u8282\u70b9\uff0c\u4ee5\u53ca\u8be5\u8282\u70b9\u5bf9\u5e94\u7684\u4e0b\u4e00\u4e2a\u8282\u70b9\n    if(heap_free_first == (void  *)-1) return -1;\n\n    WRITE(heap_free_first, 0);//\u7b2c\u4e00\u4e2a\u5757\u7528\u4e8e\u5bf9\u9f50\uff0c\u7a7a\u6570\u636e\n    WRITE(heap_free_first + WORD_SIZE, PACK(33 * sizeof(void*), 1));//\u7b2c\u4e8c\u4e2a\u5757\u7528\u4e8e\u5e8f\u8a00\u5934\uff0c\u5e8f\u8a00\u5757\u957f\u5ea6\u4e3a33 * sizeof(void*)\uff0c\u8bbe\u5b9a\u4e3a\u5df2\u7ecf\u5206\u914d\n    for(int i = 1; i &lt; 33; i++){\n        PUTADDR((heap_free_first + i * sizeof(void*)), NULL);\n    }//\u5b58\u653e\u7a7a\u95f2\u94fe\u8868\u5934\u8282\u70b9\n    WRITE(heap_free_first + 33 * sizeof(void*), PACK(33 * sizeof(void*), 1));//\u7b2c\u516d\u90e8\u5206\u662f\u4e00\u4e2a\u5e8f\u8a00\u5c3e\uff0c\u521a\u597d\u4e00\u4e2a\u5e8f\u8a00\u5757\u662f24\n    WRITE(heap_free_first + 33 * sizeof(void*) + WORD_SIZE, PACK(0, 1));//\u7ed3\u5c3e\u5757\n\n    heap_free_first = heap_free_first + 2 * WORD_SIZE;//\u62ff\u7a7a\u6570\u636e\u5757\u4f5c\u4e3a\u7a7a\u95f2\u5217\u8868\u8d77\u70b9\n    heap_free_last = heap_free_first + 32 * sizeof(void*);//\u8bbe\u5b9a\u6700\u7ec8\u5934\u8282\u70b9\u4f5c\u4e3a\u8fb9\u754c\u6761\u4ef6\n\n    return 0;\n}\n\n/* \n * mm_malloc - Allocate a block by incrementing the brk pointer.\n *     Always allocate a block whose size is a multiple of the alignment.\n */\nvoid *mm_malloc(size_t size)\n{\n    // If size equals zero, which means we don't need to execute malloc\n    if (size == 0) return NULL;\n    // Add header size and tailer size to block size\n    size += (WORD_SIZE &lt;&lt; 1);\n    // Round up size to mutiple of 8\n    if ((size &amp; (unsigned int)7) &gt; 0) size += (1 &lt;&lt; 3) - (size &amp; 7);\n    if(size &lt; 24) size = 24;//\u5c06\u8d1f\u8f7d\u6269\u5c55\u523024\n    // We call first fit function to find a space with size greater than argument 'size'\n    void *Ptr = FirstFit(size);\n    // If first fit function return NULL, which means there's no suitable space.\n    // Else we find it. The all things to do is to place it.\n    if (Ptr != NULL) {\n        Place(Ptr, size);\n        return Ptr;\n    }\n    // We call sbrk to extend heap size\n    int LOWPAGE = PAGE_SIZE;\n    if(size == 24) LOWPAGE = 5120;//\u9762\u5411binary2\n    else if(size == 72) LOWPAGE = 4224;//\u9762\u5411binary\n    unsigned int SbrkSize = MAX(size, LOWPAGE);\n    void *NewPtr = mem_sbrk(SbrkSize);\n    if (NewPtr == (void *)-1) return NULL;\n    // Write metadata in newly requested space\n    WRITE(NewPtr - WORD_SIZE, PACK(SbrkSize, 0));\n    WRITE(mem_heap_hi() - 3 - WORD_SIZE, PACK(SbrkSize, 0));\n    WRITE(mem_heap_hi() - 3, PACK(0, 1));\n    insert_free(NewPtr);\n    // Execute function merge to merge new space and free block in front of it\n    NewPtr = Merge(NewPtr);\n    // Execute function place to split the free block to 1/2 parts\n    Place(NewPtr, size);\n    return NewPtr;\n}\n\n/*\n * mm_free - Freeing a block does nothing.\n */\nvoid mm_free(void *ptr)\n{\n    // We just fill in the header and tailer with PACK(Size, 0)\n    void *Header = HEAD_PTR(ptr), *Tail = TAIL_PTR(ptr);\n    unsigned int Size = GET_SIZE(Header);\n    WRITE(Header, PACK(Size, 0));\n    WRITE(Tail, PACK(Size, 0));\n    insert_free(ptr);\n    // Then merge it with adjacent free blocks\n    ptr = Merge(ptr);\n}\n\n/*\n * mm_realloc - Implemented simply in terms of mm_malloc and mm_free\n */\nvoid *mm_realloc(void *ptr, size_t size)\n{\n    // We get block's original size\n    unsigned int BlkSize = GET_SIZE(HEAD_PTR(ptr));\n    // Round up size to mutiple of 8\n    if ((size &amp; (unsigned int)7) &gt; 0) size += (1 &lt;&lt; 3) - (size &amp; 7);\n    // If original size is greater than requested size, we don't do any.\n    if (BlkSize &gt;= size + WORD_SIZE * 2) return ptr;\n    // Else, we call malloc to get a new space for it.\n    void *NewPtr = mm_malloc(size);\n    if (NewPtr == NULL) return NULL;\n    // Move the data to new space\n    memmove(NewPtr, ptr, size);\n    // Free old block\n    mm_free(ptr);\n    return NewPtr;\n}\n</code></pre> <p>\\(\\Gamma(z) = \\int_0^\\infty t^{z-1}e^{-t}dt\\,.\\)</p>","tags":["difficult","meaningful"]},{"location":"blog/archive/2025/","title":"2025","text":""},{"location":"blog/category/xjtuicslab/","title":"xjtuicslab","text":""}]}